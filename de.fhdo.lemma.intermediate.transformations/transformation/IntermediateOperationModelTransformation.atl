-- @path Operation=/de.fhdo.lemma.operationdsl.metamodel/model/OperationViewpointModel.xcore
-- @path Intermediate=/de.fhdo.lemma.operationdsl.intermediate.metamodel/model/IntermediateOperationModel.xcore

-- Author: Philip Wizenty
-- E-mail: philip.wizenty@fh-dortmund.de

module IntermediateOperationModelTransformation;
create OUT : Intermediate from IN : Operation;

--- Rule to generate the root of the target intermediate Operation model
unique lazy rule IntermediateOperationModel {
    from
        s : Operation!OperationModel
    to
        t : Intermediate!IntermediateOperationModel(
            sourceModelUri <- Operation!OperationModel.allInstances().first().t_modelUri
        )
    do {
        t;
    }
}

--- Transform a source Import to a target IntermediateImport
rule IntermediateImport {
    from
        i : Operation!Import
    to
        t : Intermediate!IntermediateImport(
            name <- i.name,
            importUri <- i.importURI,
            -- Note that normally this would be a direct mapping between the source and the target
            -- importType. However, the XMI serlializer seems to be bugged. See the comments in the
            -- metamodel on why here the name of the import type is used instead.
            importTypeName <- thisModule.getImportTypeName(i)
        )
    do {
        -- Assign created target instance to the list of imports under the model root
        thisModule.IntermediateOperationModel().imports <- thisModule.IntermediateOperationModel()
            .imports->append(t);
    }
}

--- Helper to get the name of an import type without preceding hash sign ('#')
helper def : getImportTypeName(import : Operation!Import) : String =
    let
        rawImportTypeName : String = import.importType.toString()
    in
    if (rawImportTypeName.startsWith('#')) then
        rawImportTypeName.substring(2, rawImportTypeName.size())
    else
        rawImportTypeName
    endif
;

--- Transform a source Container, to an IntermediateContainer
rule IntermediateContainer {
    from
        s : Operation!Container
    to
        t : Intermediate!IntermediateContainer(
            name <- s.name,
            imports <- s.technologies,
            technologyReference <- thisModule.IntermediateDeploymentTechnologyReference(
                s.deploymentTechnology, s.operationEnvironment),
            operationModel <- thisModule.IntermediateOperationModel()
            )
    do {
        -- Assign a OperationEnvironment to the container
        if (not t.technologyReference.deploymentTechnology.environment.oclIsUndefined()) {
              t.operationEnvironment <- t.technologyReference.deploymentTechnology.environment;
        }

        -- Assign a ServiceDeplymentSpecification to the container
        for (deploymentSpecification in s.deploymentSpecifications) {
            t.specifications <- thisModule.IntermediateServiceDeploymentSpecification(t,
                deploymentSpecification);
        }

        -- Assign DefaultBasicEndpoints to the container
        for (defaultBasicEndpoint in s.defaultBasicEndpoints) {
            for (protocol in defaultBasicEndpoint.protocols) {
                t.endpoints <- thisModule.IntermediateEndpoint(defaultBasicEndpoint, protocol);
            }
        }

        -- Assign the DeployedServices of the contaier
        for (deployedService in s.deployedServices) {
           t.deployedServices <- thisModule.OperationMicroserviceReference(deployedService);
        }

        -- Assign the DefaultServicePropertyValues to the Container
        for (propertyValue in s.defaultServicePropertyValues) {
            t.propertyValues <- thisModule.IntermediateTechnologySpecificPropertyValue(
                OclUndefined, propertyValue);
        }

        -- Assign the operational Aspect to the container
        for (aspect in s.aspects) {
            t.aspects <- thisModule.IntermediateImportedAspect(t, aspect);
        }
    }
}

--- Called rule to create an IntermediateDeploymentTechnologyReference instance
rule IntermediateDeploymentTechnologyReference(
    sourceTechnologyReference : Operation!DeploymentTechnologyReference,
    sourceEnvironment : Operation!OperationEnvironment) {
    to
        t : Intermediate!IntermediateDeploymentTechnologyReference(
                import <- sourceTechnologyReference.import,
                deploymentTechnology <- thisModule.IntermediateDeploymentTechnology(
                    sourceTechnologyReference.deploymentTechnology)
        )
    do {
        -- Link an OperationEnvironment to the DeploymentTechnologyReference if present
        if(not sourceEnvironment.oclIsUndefined()) {
            thisModule.IntermediateOperationEnvironment(sourceEnvironment, t.deploymentTechnology);
        }
        t;
    }
}

--- Called rule to create an IntermediateDeploymentTechnology instance
rule IntermediateDeploymentTechnology(sourceDeploymentTechnology : Operation!DeploymentTechnology) {
    to
        t : Intermediate!IntermediateDeploymentTechnology(
            name <- sourceDeploymentTechnology.name,
            operationModel <- thisModule.IntermediateOperationModel()
        )
    do {
        -- Assign a TechnologySpecificProperty to a DeploymentTechnology
        for (technologySpecificProperty in sourceDeploymentTechnology.serviceProperties){
            t.propertys.append(thisModule.IntermediateTechnologySpecificProperty(
                technologySpecificProperty, t));
        }
        t;
    }
}

--- Called rule to create an IntermediateOperationEnvironment instance
rule IntermediateOperationEnvironment(sourceEnvironment : Operation!OperationEnvironment,
    technology : Intermediate!IntermediateDeploymentTechnology) {
    to
        t : Intermediate!IntermediateOperationEnvironment(
            environmentName <- sourceEnvironment.environmentName,
            operationTechnology <- technology,
            default <- sourceEnvironment.default
        )
}

--- Transform a source InfrastructureNode, to a target IntermediateInfrastructureNode
rule IntermediateInfrastructureNode {
    from
        s : Operation!InfrastructureNode
    to
        t : Intermediate!IntermediateInfrastructureNode(
            name <- s.name,
            imports <- s.technologies,
            reference <- thisModule.IntermediateInfrastructureTechnologyReference(
                s.infrastructureTechnology, s.operationEnvironment),
            operationModel <- thisModule.IntermediateOperationModel()
        )
    do {
        -- Assign an OperationEvironment to the InfrastructureNode
        if (not t.reference.infrastructureTechnology.environment.oclIsUndefined()) {
              t.operationEnvironment <- t.reference.infrastructureTechnology.environment;
        }

        -- Assign Endpoints to the InfrastructureNode, note that each protocol results in a seperate
        --  endpoint
        for (infrastructureEndpoint in s.endpoints) {
            for (protocol in infrastructureEndpoint.protocols) {
                t.endpoints <- thisModule.IntermediateEndpoint(infrastructureEndpoint, protocol);
            }
        }

        -- Assign nodes on which the InfrastructureNode depens on
        for (node in s.dependsOnNodes) {
            t.dependsOnNodes <- Intermediate!IntermediateOperationNode.allInstances()
                ->any(p | p.name = node.name);
        }

        -- Assign nodes which the InfrastrucureNode uses
        for (node in s.usedByNodes) {
            t.usedByNodes <- Intermediate!IntermediateOperationNode.allInstances()
                ->any(p | p.name = node.name);
        }

        -- ServiceDeploymentSpecification is missing for infrastructural nodes. The DSL only allows
        -- a specification for imported Microservices, not for infrastructure nodes.

        -- Assign DefaultServicePropertyValues to the InfrastructureNode
        -- The ServiceDeploymentSpecification is oclUndefined in this use of the called rule
        -- but necessary to reuse it in the ServiceDeploymentSpecificatio called rule
        for (propertyValue in s.defaultServicePropertyValues) {
            t.propertyValues <- thisModule.IntermediateTechnologySpecificPropertyValue(
                OclUndefined, propertyValue);
        }

        -- Assign OperationAspects to the InfrastructureNode
        for (aspect in s.aspects) {
            t.aspects <- thisModule.IntermediateImportedAspect(t, aspect);
        }
    }
}

--- Called rule to create a IntermediateInfrastructureTechnologyReference instance
rule IntermediateInfrastructureTechnologyReference(sourceTechnologyReference :
   Operation!InfrastructureTechnologyReference, sourceEnvironment : Operation!OperationEnvironment){
    to
        t: Intermediate!IntermediateInfrastructureTechnologyReference(
            import <- sourceTechnologyReference.import,
            infrastructureTechnology <- thisModule.IntermediateInfrastructureTechnology(
                sourceTechnologyReference.infrastructureTechnology)
        )
    do {
        if(not sourceEnvironment.oclIsUndefined()) {
            thisModule.IntermediateOperationEnvironment(sourceEnvironment,
                t.infrastructureTechnology);
        }
        t;
    }
}

--- Called rule to create a IntermediateDeploymentTechnology instance
rule IntermediateInfrastructureTechnology(sourceInfrastructureTechnology :
    Operation!InfrastructureTechnology) {
    to
        t: Intermediate!IntermediateInfrastructureTechnology(
            name <- sourceInfrastructureTechnology.name,
            operationModel <- thisModule.IntermediateOperationModel()
        )
    do {
        t;
    }
}

--- Called rule to creade a IntermediateTechnologySpecificProperty instance
rule IntermediateTechnologySpecificProperty(sourceTechnologySpecificProperty :
    Operation!TechnologySpecificProperty,
    deploymentTechnology : Intermediate!IntermediateDeploymentTechnology) {
    to
        t : Intermediate!IntermediateTechnologySpecificProperty(
            name <- sourceTechnologySpecificProperty.name,
            type <- sourceTechnologySpecificProperty.type.typeName,
            operationTechnology <- deploymentTechnology
        )

    do {
        -- Assign a DefaultValue to a TechnologySpecificProperty if available
        if (not sourceTechnologySpecificProperty.defaultValue.oclIsUndefined()){
            t.defaultValue <- sourceTechnologySpecificProperty.defaultValue.valueAsString();
        }

        -- Assign a Feature to a TechnologySpecificProperty
        for (feature in sourceTechnologySpecificProperty.features){
            t.featureNames <- feature.toString();
        }
        t;
    }
}

--- Called rule to create a IntermediateTechnologySpecificPropertyValue instance
rule IntermediateTechnologySpecificPropertyValue (deploymentSpecification :
    Intermediate!IntermediateServiceDeploymentSpecification,
    servicePropertyValue : Operation!TechnologySpecificPropertyValueAssignment) {
    to
        t : Intermediate!IntermediateTechnologySpecificPropertyValue(
            value <- servicePropertyValue.value.valueAsString(),
            technologySpecificProperty <- Intermediate!IntermediateTechnologySpecificProperty
                .allInstances()->any(p | p.name = servicePropertyValue.property.name)
        )
    do {
        t;
    }
}

--- Called rule to create a IntermediateServiceDeploymentSpecification instance
rule IntermediateServiceDeploymentSpecification(
    targetContainer : Intermediate!IntermediateContainer,
    sourceDeploymentSpecification :Operation!ServiceDeploymentSpecification) {
        to
            t : Intermediate!IntermediateServiceDeploymentSpecification(
                operationNode <- targetContainer
            )
        do{
            -- Assign a TechnologySpecificPropertyValue to a DeploymentSpecification
            for (servicePropertyValue in sourceDeploymentSpecification.servicePropertyValues) {
                t.propertyValues <- thisModule.IntermediateTechnologySpecificPropertyValue(t,
                    servicePropertyValue);
            }

            -- Assign a BasicEndpoint to a DeploymentSpecification
            for (basicEndpoint in sourceDeploymentSpecification.basicEndpoints) {
                for (protocol in basicEndpoint.protocols) {
                    t.endpoints <- thisModule.IntermediateEndpoint(basicEndpoint, protocol);
                }
            }
            t;
        }
}

--- Called rule to create a IntermediateServiceDeploymentSpecification instance
rule OperationMicroserviceReference(sourceMicroservice : Operation!ImportedMicroservice) {
    to
        t : Intermediate!OperationMicroserviceReference(
            name <- sourceMicroservice.microservice.name,
            effectivelyImplemented <- sourceMicroservice.microservice.effectivelyImplemented,
            import <- Intermediate!IntermediateImport.allInstances()
                -> any(p | p.name = sourceMicroservice.import.name),
            version <- sourceMicroservice.microservice.version,
            qualifiedName <- sourceMicroservice.microservice.buildQualifiedName('.'),
            visibility <- sourceMicroservice.microservice.effectiveVisibility
        )
    do {
        t.node <- Intermediate!IntermediateOperationNode.allInstances()
            ->any(p | p.name = sourceMicroservice.operationNode.name);
        t;
    }
}

--- Called rule to create a IntermediateEndPoint instance
rule IntermediateEndpoint(sourceEndpoint : Operation!BasicEndpoint,
    sourceProtocol : Operation!ProtocolAndDataFormat) {
    to
        t : Intermediate!IntermediateEndpoint(
            addresses <- sourceEndpoint.addresses,
            protocol <- sourceProtocol.protocol.name,
            communicationType <- sourceProtocol.protocol.communicationType.toString()
        )
    do {
        if(not sourceProtocol.dataFormat.oclIsUndefined()) {
            t.dataFormat <- sourceProtocol.dataFormat;
        }
        t.dataFormat <- sourceProtocol.protocol.defaultFormat.formatName;
        t;
    }
}

--- Create an IntermediateImportedAspect from an ImportedServiceAspect instance
rule IntermediateImportedAspect (operationNode : Intermediate!IntermediateOperationNode,
sourceAspect : Operation!ImportedOperationAspect) {
    to
        t : Intermediate!IntermediateImportedAspect(
            name <- sourceAspect.aspect.name,
            import <- Intermediate!IntermediateImport.allInstances()
                -> any(p | p.name = sourceAspect.technology.name)
        )
    do {
        -- Aspect features
        for (feature in sourceAspect.aspect.features) {
            t.featureNames <- t.featureNames.append(feature.toString());
        }

        -- Create properties of aspect and link them with the aspect
        for (property in sourceAspect.aspect.properties) {
            t.properties <- t.properties->append(
                thisModule.IntermediateAspectProperty(property, t)
            );
        }

        -- Create values of aspect and link them with the aspect. Therefore, we consider both, the
        -- syntactically shorter initialization of a single property aspect and the "normal" case of
        -- "named" property initialization. Independent of how the aspect and its values were
        -- specified, we map an aspect value to a an IntermediateAspectPropertyValue instance.
        if (not sourceAspect.singlePropertyValue.oclIsUndefined())
            thisModule.IntermediateAspectPropertyValue(sourceAspect.singlePropertyValue, t,
                t.properties->first());
        else
            for (value in sourceAspect.values) {
                thisModule.IntermediateAspectPropertyValue(value.value, t,
                    t.properties->any(p | p.name = value.property.name));
        }
        t;
    }
}

--- Called rule to create an IntermediateAspectProperty instance
rule IntermediateAspectProperty(sourceProperty : Service!TechnologySpecificProperty,
    aspect : Intermediate!IntermediateImportedAspect) {
    to
        i : Intermediate!IntermediateAspectProperty(
            name <- sourceProperty.name,
            type <- sourceProperty.type.typeName,
            aspect <- aspect
        )
    do {
        for (feature in sourceProperty.features) {
            i.featureNames <- i.featureNames.append(feature.toString());
        }

        if (not sourceProperty.defaultValue.oclIsUndefined())
            i.defaultValue <- sourceProperty.defaultValue.valueAsString();

        aspect.properties <- aspect.properties->append(i);
        i;
    }
}

--- Called rule to create an IntermediateAspectPropertyValue instance
rule IntermediateAspectPropertyValue(sourceValue : Service!PrimitiveValue,
    aspect : Intermediate!IntermediateImportedAspect,
    property : Intermediate!IntermediateAspectProperty) {
    to
        i : Intermediate!IntermediateAspectPropertyValue(
            value <- sourceValue.valueAsString(),
            aspect <- aspect,
            property <- property
        )
    do {
        aspect.propertyValues->append(i);
        i;
    }
}